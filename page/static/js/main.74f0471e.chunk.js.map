{"version":3,"sources":["utils/common.ts","store/game/actions.ts","utils/directions.ts","utils/game.ts","utils/history.ts","store/game/reducer.ts","LocalStorageHandler.ts","store/game/selectors.ts","store/localStorageMiddleware.ts","store/index.ts","hooks/usePrevious.ts","components/ai/DummyAI.tsx","hooks/useIsCellUnderHit.ts","components/piece/useIsPieceInteractive.ts","components/piece/useIsPieceMandatoryToMakeTurn.ts","common.styled.tsx","components/piece/Piece.styled.tsx","components/piece/Piece.tsx","components/cell/useGetCellHighlight.ts","components/cell/useGetCellAction.ts","components/cell/Cell.styled.tsx","components/cell/Cell.tsx","components/board/DragNDropLayer.tsx","components/board/BoardLayout.styled.tsx","components/board/BoardLayout.tsx","components/menu-button/MenuButton.styled.tsx","components/menu-button/MenuButton.tsx","components/start-game/StartGame.styled.tsx","components/start-game/StartGame.tsx","components/board-menu/BoardMenu.styled.tsx","components/board-menu/BoardMenu.tsx","components/winner/Winner.styled.tsx","components/winner/Winner.tsx","components/main-container/MainContainerContent.tsx","components/main-container/MainContainer.styled.tsx","components/main-container/MainContainer.tsx","App.tsx","index.tsx"],"names":["createBoardSchema","Array","from","map","_","i","hasOffset","createRowSchema","getCellIndex","rowIndex","colIndex","getOffsetCoordinate","rowOffset","colOffset","getCellCoordinateFromIndex","index","split","Number","areCoordinatesEqual","coordinate","coordinateToCompare","rowIndexToCompare","colIndexToCompare","getDefaultPieceByRowIndex","color","isRisen","isQueen","getRandomInt","min","max","Math","floor","random","ceil","RISE_PIECE","PUT_PIECE","MOVE_PIECE","HOVER_CELL","HIT_PIECE","NEW_GAME","SET_STATE","UNDO","movePiece","fromCoordinate","toCoordinate","type","payload","hoverPiece","hitPiece","hitCoordinate","directionOffsets","getDirectionOffset","direction","isRouteWithHitPiece","route","some","routeItem","cell","piece","getAvailableRoutes","state","availableRoutes","Object","entries","filter","directionOffset","availableCell","getAvailableDirections","nextCellCoordinate","nextCell","nextAfterNextCellCoordinate","nextAfterNextCell","getDummyAvailableRoute","length","routesWithHit","getRouteWithCell","routes","cellCoordinate","find","availableRoute","routeContainsCell","getIsQueen","movedTo","getMandatoryTurnPieceAfterHitCoordinate","stateAfterHit","coordinateAfterHit","getPlayerPiecesCoordinates","player","reduce","result","key","getAvailableTurnPieces","piecesWithTurns","piecesWithHits","pieceWithRoute","getNextPlayer","currentPlayer","hasAdditionalHitTurn","getStateWithMovedPiece","cellsState","cellIndexFrom","cellIndexTo","cellFrom","cellTo","getStateWithHitPiece","hitPieceCoordinate","cellIndexHit","cellHit","getHistoryEntry","currentState","cells","availableTurnPieces","mandatoryTurnPiece","initialPlayer","defaultCellsState","gameState","row","rowResult","createDefaultCellsRow","defaultAvailableTurnCells","initialAvailableTurnPieces","defaultGameState","availableTurnRoutes","selectedPieceCoordinate","hoveredCellCoordinate","history","mode","LOCAL_STORAGE_KEY","clearGameFromLocalStorage","window","localStorage","removeItem","selectCells","game","getSelectPieceState","selectSelectedPieceCoordinate","selectAvailableTurnCells","selectCurrentPlayer","selectGameMode","selectMandatoryTurnPiece","localStorageMiddleware","getState","next","action","nextAction","includes","selectGameState","setItem","JSON","stringify","store","createStore","combineReducers","nextPlayer","updatedCellsState","updatedState","lastState","slice","applyMiddleware","usePrevious","value","ref","React","useRef","useEffect","current","AI_PLAYER","DummyAI","dispatch","useDispatch","useSelector","previousPlayer","previousMandatoryTurnPiece","console","log","hitPieceAction","useCallback","pieceCoordinate","hitRoute","cellAfterHitCoordinate","setTimeout","movePieceAction","moveRoute","moveCoordinate","chosenPiece","chosenRoute","useIsCellUnderHit","availableTurnCells","useIsPieceInteractive","isAvailable","availablePieceCoordinate","getSelectIsPieceAvailableForTurn","gameMode","useIsPieceMandatoryToMakeTurn","BOARD_SIZE_PX","CELL_SIZE","COLOR_BLACK","COLOR_WHITE","COLOR_MAIN","COLOR_ACCENT","getStripedPattern","sizePx","css","GlobalStyle","createGlobalStyle","$PieceContainer","styled","div","isVisible","isInteractive","props","isPieceHit","pieceColor","$Piece","isMandatory","$Shadow","getDottedPattern","Piece","pieceElementRef","createRef","getSelectIsPieceRisen","selectedPieceCoordinates","isPieceInteractive","onKeyDown","risePiece","onMouseEnter","onMouseLeave","onMouseDown","useGetCellHighlight","currentCellPiece","isHitRoute","useGetCellAction","hitPieceRouteItem","$Cell","highlight","getBackgroundColor","Cell","onMouseUp","DragNDropLayer","event","style","top","clientY","left","clientX","onMouseMove","document","addEventListener","removeEventListener","$Board","$PlayerName","isActive","position","defaultSchema","BoardLayout","activePlayer","prevCell","coordinates","undefined","$Button","button","SHADOW_SIZE_PX","MenuButton","label","onClick","$StartGameContainer","$Title","h2","StartGame","onModeSelect","$Container","BoardMenu","onUndo","onStartNewGame","$WinnerContainer","Winner","winner","MainContainerContent","useState","screen","setScreen","setWinner","currentWinner","whitePlayerPieces","blackPlayerPieces","getWinner","savedState","savedGame","getItem","parse","readGameFromLocalStorage","openStartScreen","onStartGame","$MainContainer","$MainHeader","h1","MainContainer","currentGameMode","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.74f0471e.chunk.js","sourcesContent":["import {\n  Coordinate,\n  CellsMap,\n  CellState,\n  Piece, DirectionOffset,\n} from '../types';\n\nexport const BOARD_SIZE = 8;\n\nexport const createRowSchema = (hasOffset = false): boolean[] => Array.from(Array(BOARD_SIZE))\n  .map((_, i) => (hasOffset ? i % 2 === 1 : i % 2 === 0));\n\nexport const createBoardSchema = (): boolean[][] => Array.from(Array(BOARD_SIZE))\n  .map((_, i) => createRowSchema(i % 2 === 0));\n\nexport const getCellIndex = ({ rowIndex, colIndex }: Coordinate): string => `${rowIndex}-${colIndex}`;\n\nexport const getOffsetCoordinate = (\n  { rowIndex, colIndex }: Coordinate,\n  { rowOffset, colOffset }: DirectionOffset,\n): Coordinate => ({\n  rowIndex: rowIndex + rowOffset,\n  colIndex: colIndex + colOffset,\n});\n\nexport const getCellCoordinateFromIndex = (index: string): Coordinate => {\n  const [rowIndex, colIndex] = index.split('-');\n\n  return {\n    colIndex: Number(colIndex),\n    rowIndex: Number(rowIndex),\n  };\n};\n\nexport const areCoordinatesEqual = (\n  coordinate: Coordinate,\n  coordinateToCompare: Coordinate,\n): boolean => {\n  const { rowIndex, colIndex } = coordinate;\n  const { rowIndex: rowIndexToCompare, colIndex: colIndexToCompare } = coordinateToCompare;\n\n  return rowIndex === rowIndexToCompare && colIndex === colIndexToCompare;\n};\n\nconst getDefaultPieceByRowIndex = (rowIndex: number): Piece | null => {\n  if (rowIndex < 3) {\n    return {\n      color: 'black',\n      isRisen: false,\n      isQueen: false,\n    };\n  }\n\n  if (rowIndex > 4) {\n    return {\n      color: 'white',\n      isRisen: false,\n      isQueen: false,\n    };\n  }\n\n  return null;\n};\n\nconst createDefaultCellsRow = (\n  rowIndex: number,\n  row: boolean[],\n) => row.reduce<CellsMap>((rowResult, cell, colIndex) => {\n  // skip white cells\n  if (!cell) {\n    return rowResult;\n  }\n\n  return {\n    ...rowResult,\n    [getCellIndex({ rowIndex, colIndex })]: {\n      piece: getDefaultPieceByRowIndex(rowIndex),\n    } as CellState,\n  };\n}, {});\n\nexport const createDefaultCellsState = (): CellsMap => {\n  const defaultSchema = createBoardSchema();\n\n  return defaultSchema\n    .reduce<CellsMap>((gameState, row, rowIndex) => ({\n      ...gameState,\n      ...createDefaultCellsRow(rowIndex, row),\n    }), {});\n};\n\nexport const getRandomInt = (min: number, max: number): number => (\n  Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min)) + Math.ceil(min))\n);\n","import { Coordinate, GameMode } from '../../types';\nimport { GameState } from './reducer';\n\nexport const RISE_PIECE = 'game/RISE_PIECE';\nexport const PUT_PIECE = 'game/PUT_PIECE';\nexport const MOVE_PIECE = 'game/MOVE_PIECE';\nexport const HOVER_CELL = 'game/HOVER_CELL';\nexport const HIT_PIECE = 'game/HIT_PIECE';\nexport const NEW_GAME = 'game/NEW_GAME';\nexport const SET_STATE = 'game/SET_STATE';\nexport const UNDO = 'game/UNDO';\n\ninterface RisePieceAction {\n  type: typeof RISE_PIECE;\n  payload: Coordinate;\n}\n\ninterface PutPieceAction {\n  type: typeof PUT_PIECE;\n  payload: Coordinate;\n}\n\ninterface MovePieceAction {\n  type: typeof MOVE_PIECE;\n  payload: {\n    fromCoordinate: Coordinate,\n    toCoordinate: Coordinate,\n  };\n}\n\ninterface HoverPieceAction {\n  type: typeof HOVER_CELL;\n  payload: Coordinate | null;\n}\n\ninterface HitPieceAction {\n  type: typeof HIT_PIECE;\n  payload: {\n    fromCoordinate: Coordinate,\n    hitCoordinate: Coordinate,\n    toCoordinate: Coordinate,\n  };\n}\n\ninterface UndoAction {\n  type: typeof UNDO;\n}\n\ninterface NewGameAction {\n  type: typeof NEW_GAME;\n  payload: GameMode;\n}\n\ninterface SetStateAction {\n  type: typeof SET_STATE;\n  payload: GameState;\n}\n\nexport const risePiece = (coordinate: Coordinate): RisePieceAction => ({\n  type: RISE_PIECE,\n  payload: coordinate,\n});\n\nexport const putPiece = (coordinate: Coordinate): PutPieceAction => ({\n  type: PUT_PIECE,\n  payload: coordinate,\n});\n\nexport const movePiece = (\n  fromCoordinate: Coordinate,\n  toCoordinate: Coordinate,\n): MovePieceAction => ({\n  type: MOVE_PIECE,\n  payload: {\n    fromCoordinate,\n    toCoordinate,\n  },\n});\n\nexport const hoverPiece = (\n  coordinate: Coordinate | null,\n): HoverPieceAction => ({\n  type: HOVER_CELL,\n  payload: coordinate,\n});\n\nexport const hitPiece = (\n  fromCoordinate: Coordinate,\n  hitCoordinate: Coordinate,\n  toCoordinate: Coordinate,\n): HitPieceAction => ({\n  type: HIT_PIECE,\n  payload: {\n    fromCoordinate,\n    hitCoordinate,\n    toCoordinate,\n  },\n});\n\nexport const undo = (): UndoAction => ({\n  type: UNDO,\n});\n\nexport const startGame = (payload: GameMode): NewGameAction => ({\n  type: NEW_GAME,\n  payload,\n});\n\nexport const setGameState = (payload: GameState): SetStateAction => ({\n  type: SET_STATE,\n  payload,\n});\n\nexport type GameAction =\n  | RisePieceAction\n  | PutPieceAction\n  | MovePieceAction\n  | HoverPieceAction\n  | HitPieceAction\n  | UndoAction\n  | NewGameAction\n  | SetStateAction;\n","import {\n  CellsMap, Coordinate, Direction, DirectionOffset,\n} from '../types';\nimport { getCellIndex, getOffsetCoordinate } from './common';\n\nconst directionOffsets = {\n  'top-right': {\n    rowOffset: -1,\n    colOffset: 1,\n  },\n  'top-left': {\n    rowOffset: -1,\n    colOffset: -1,\n  },\n  'bottom-right': {\n    rowOffset: 1,\n    colOffset: 1,\n  },\n  'bottom-left': {\n    rowOffset: 1,\n    colOffset: -1,\n  },\n};\n\nexport const getDirectionOffset = (\n  direction: Direction,\n): DirectionOffset => directionOffsets[direction];\n\nexport const getAvailableDirections = (\n  state: CellsMap,\n  coordinate: Coordinate,\n): Direction[] => Object.entries(directionOffsets)\n  .filter(([direction, directionOffset]) => {\n    const { piece } = state[getCellIndex(coordinate)];\n\n    if (piece === null) {\n      return false;\n    }\n\n    const availableCell = state[getCellIndex(getOffsetCoordinate(coordinate, directionOffset))];\n\n    if (!availableCell) {\n      return false;\n    }\n\n    // piece exists in current direction\n    if (availableCell.piece) {\n      return availableCell.piece.color !== piece.color;\n    }\n\n    // cell is empty in current direction\n    // todo: queen piece\n    if (piece.color === 'black') {\n      return direction === 'bottom-left' || direction === 'bottom-right';\n    }\n\n    return direction === 'top-left' || direction === 'top-right';\n  }).map(([direction]) => direction as Direction);\n","import {\n  CellsMap, Coordinate, Direction, Piece, PlayerType, Route, RouteItem,\n} from '../types';\nimport { getCellCoordinateFromIndex, getCellIndex, getOffsetCoordinate } from './common';\nimport { getAvailableDirections, getDirectionOffset } from './directions';\n\n// gets dummy route just two cells ahead\n// recursion can be used to get routes for queen cells\nconst getDummyAvailableRoute = (\n  state: CellsMap,\n  direction: Direction,\n  coordinate: Coordinate,\n): RouteItem[] => {\n  const nextCellCoordinate = getOffsetCoordinate(coordinate, getDirectionOffset(direction));\n  const nextCell = state[getCellIndex(nextCellCoordinate)];\n\n  if (nextCell.piece === null) {\n    return [{\n      cell: nextCell,\n      coordinate: nextCellCoordinate,\n    }];\n  }\n\n  const nextAfterNextCellCoordinate = getOffsetCoordinate(\n    nextCellCoordinate,\n    getDirectionOffset(direction),\n  );\n  const nextAfterNextCell = state[getCellIndex(nextAfterNextCellCoordinate)];\n\n  if (nextAfterNextCell && nextAfterNextCell.piece === null) {\n    return [{\n      cell: nextCell,\n      coordinate: nextCellCoordinate,\n    }, {\n      cell: nextAfterNextCell,\n      coordinate: nextAfterNextCellCoordinate,\n    }];\n  }\n\n  return [];\n};\n\nexport const isRouteWithHitPiece = (route: RouteItem[]): boolean => route\n  .some((routeItem) => routeItem.cell.piece);\n\nexport const routeContainsCell = (route: RouteItem[], cellCoordinate: Coordinate): boolean => route\n  .some((routeItem) => getCellIndex(routeItem.coordinate) === getCellIndex(cellCoordinate));\n\nexport const getAvailableRoutes = (\n  state: CellsMap,\n  coordinate: Coordinate,\n): Route[] => {\n  const cell = state[getCellIndex(coordinate)];\n\n  if (!cell || !cell.piece) {\n    return [];\n  }\n\n  const availableDirections = getAvailableDirections(state, coordinate);\n\n  const availableRoutes = availableDirections\n    .map((direction) => getDummyAvailableRoute(state, direction, coordinate))\n    .filter((route) => route.length);\n\n  const routesWithHit = availableRoutes.filter(isRouteWithHitPiece);\n\n  return routesWithHit.length ? routesWithHit : availableRoutes;\n};\n\nexport const getRouteWithCell = (\n  routes: Route[],\n  cellCoordinate: Coordinate,\n): RouteItem[] | undefined => routes\n  .find((availableRoute) => routeContainsCell(availableRoute, cellCoordinate));\n\nconst getIsQueen = (piece: Piece | null, movedTo: Coordinate): boolean => {\n  if (!piece) {\n    return false;\n  }\n\n  return piece.isQueen\n    || (piece.color === 'white' && movedTo.rowIndex === 0)\n    || (piece.color === 'black' && movedTo.rowIndex === 7);\n};\n\nexport const getMandatoryTurnPieceAfterHitCoordinate = (\n  stateAfterHit: CellsMap,\n  coordinateAfterHit: Coordinate,\n): Coordinate | null => {\n  const availableRoutes = getAvailableRoutes(stateAfterHit, coordinateAfterHit);\n\n  const hasHitRoute = availableRoutes\n    .some(isRouteWithHitPiece);\n\n  return hasHitRoute ? coordinateAfterHit : null;\n};\n\nconst getPlayerPiecesCoordinates = (state: CellsMap, player: PlayerType) => Object.entries(state)\n  .reduce((result, [key, cell]) => {\n    if (!cell.piece || cell.piece.color !== player) {\n      return result;\n    }\n\n    return [...result, getCellCoordinateFromIndex(key)];\n  }, [] as Coordinate[]);\n\nexport const getAvailableTurnPieces = (\n  state: CellsMap,\n  player: PlayerType,\n): Coordinate[] => {\n  const currentPlayerPiecesCoordinates = getPlayerPiecesCoordinates(state, player);\n\n  const piecesWithTurns = currentPlayerPiecesCoordinates.reduce((result, coordinate) => {\n    const availableRoutes = getAvailableRoutes(state, coordinate);\n\n    return availableRoutes.length ? [...result, {\n      coordinate,\n      availableRoutes,\n    }] : result;\n  }, [] as { coordinate: Coordinate, availableRoutes: Route[] }[]);\n\n  const piecesWithHits = piecesWithTurns\n    .filter((pieceWithRoute) => pieceWithRoute.availableRoutes\n      .some(isRouteWithHitPiece));\n\n  const result = piecesWithHits.length ? piecesWithHits : piecesWithTurns;\n\n  return result.map((pieceWithRoute) => pieceWithRoute.coordinate);\n};\n\nexport const getNextPlayer = (\n  currentPlayer: PlayerType,\n  hasAdditionalHitTurn: boolean,\n): PlayerType => {\n  if (hasAdditionalHitTurn) {\n    return currentPlayer;\n  }\n\n  return currentPlayer === 'white' ? 'black' : 'white';\n};\n\nexport const getWinner = (state: CellsMap): PlayerType | null => {\n  const whitePlayerPieces = getPlayerPiecesCoordinates(state, 'white');\n  const blackPlayerPieces = getPlayerPiecesCoordinates(state, 'black');\n\n  if (!whitePlayerPieces.length) {\n    return 'black';\n  }\n\n  if (!blackPlayerPieces.length) {\n    return 'white';\n  }\n\n  const hasMovesWhite = whitePlayerPieces.some((coordinate) => {\n    const availableRoutes = getAvailableRoutes(state, coordinate);\n\n    return availableRoutes.length;\n  });\n\n  if (!hasMovesWhite) {\n    return 'black';\n  }\n\n  const hasMovesBlack = blackPlayerPieces.some((coordinate) => {\n    const availableRoutes = getAvailableRoutes(state, coordinate);\n\n    return availableRoutes.length;\n  });\n\n  if (!hasMovesBlack) {\n    return 'white';\n  }\n\n  return null;\n};\n\nexport const getStateWithMovedPiece = (\n  cellsState: CellsMap,\n  fromCoordinate: Coordinate,\n  toCoordinate: Coordinate,\n): CellsMap => {\n  const cellIndexFrom = getCellIndex(fromCoordinate);\n  const cellIndexTo = getCellIndex(toCoordinate);\n  const cellFrom = cellsState[cellIndexFrom];\n  const cellTo = cellsState[cellIndexTo];\n\n  if (!cellFrom || !cellTo || !cellFrom.piece) {\n    return cellsState;\n  }\n\n  const { piece } = cellFrom;\n  const isQueen = getIsQueen(piece, toCoordinate);\n\n  return {\n    ...cellsState,\n    [cellIndexFrom]: {\n      ...cellFrom,\n      piece: null,\n    },\n    [cellIndexTo]: {\n      ...cellTo,\n      piece: {\n        ...piece,\n        isQueen,\n      },\n    },\n  };\n};\n\nexport const getStateWithHitPiece = (\n  cellsState: CellsMap,\n  fromCoordinate: Coordinate,\n  hitPieceCoordinate: Coordinate,\n  toCoordinate: Coordinate,\n): CellsMap => {\n  const cellIndexFrom = getCellIndex(fromCoordinate);\n  const cellIndexHit = getCellIndex(hitPieceCoordinate);\n  const cellIndexTo = getCellIndex(toCoordinate);\n  const cellFrom = cellsState[cellIndexFrom];\n  const cellHit = cellsState[cellIndexFrom];\n  const cellTo = cellsState[cellIndexTo];\n\n  if (!cellFrom || !cellTo || !cellHit || !cellHit.piece || !cellFrom.piece) {\n    return cellsState;\n  }\n\n  const { piece } = cellFrom;\n  const isQueen = getIsQueen(piece, toCoordinate);\n\n  return {\n    ...cellsState,\n    [cellIndexFrom]: {\n      ...cellFrom,\n      piece: null,\n    },\n    [cellIndexHit]: {\n      ...cellFrom,\n      piece: null,\n    },\n    [cellIndexTo]: {\n      ...cellTo,\n      piece: {\n        ...piece,\n        isQueen,\n      },\n    },\n  };\n};\n","import { GameState } from '../store/game/reducer';\n\nconst getHistoryEntry = (currentState: GameState): Partial<GameState> => {\n  const {\n    cells,\n    currentPlayer,\n    availableTurnPieces,\n    mandatoryTurnPiece,\n  } = currentState;\n\n  return {\n    cells,\n    currentPlayer,\n    availableTurnPieces,\n    mandatoryTurnPiece,\n  };\n};\n\nexport default getHistoryEntry;\n","import { createDefaultCellsState } from '../../utils/common';\nimport {\n  CellsMap, Coordinate, GameMode, PlayerType, Route,\n} from '../../types';\nimport {\n  GameAction,\n  HIT_PIECE,\n  HOVER_CELL,\n  MOVE_PIECE,\n  NEW_GAME,\n  PUT_PIECE,\n  RISE_PIECE,\n  SET_STATE,\n  UNDO,\n} from './actions';\nimport {\n  getAvailableTurnPieces,\n  getAvailableRoutes,\n  getMandatoryTurnPieceAfterHitCoordinate,\n  getNextPlayer,\n  getStateWithHitPiece,\n  getStateWithMovedPiece,\n} from '../../utils/game';\nimport getHistoryEntry from '../../utils/history';\n\nexport type GameState = {\n  cells: CellsMap,\n  availableTurnRoutes: Route[],\n  availableTurnPieces: Coordinate[],\n  selectedPieceCoordinate: Coordinate | null,\n  hoveredCellCoordinate: Coordinate | null,\n  mandatoryTurnPiece: Coordinate | null,\n  history: Partial<GameState>[],\n  currentPlayer: PlayerType,\n  mode: GameMode,\n};\n\nconst initialPlayer = 'white';\nconst defaultCellsState = createDefaultCellsState();\nconst defaultAvailableTurnCells: Route[] = [];\nconst initialAvailableTurnPieces = getAvailableTurnPieces(defaultCellsState, initialPlayer);\n\nconst defaultGameState: GameState = {\n  cells: defaultCellsState,\n  availableTurnRoutes: defaultAvailableTurnCells,\n  availableTurnPieces: initialAvailableTurnPieces,\n  selectedPieceCoordinate: null,\n  hoveredCellCoordinate: null,\n  mandatoryTurnPiece: null,\n  history: [],\n  currentPlayer: initialPlayer,\n  mode: 'PvP',\n};\n\nexport const reducer = (state = defaultGameState, action: GameAction): GameState => {\n  switch (action.type) {\n    case PUT_PIECE: {\n      return {\n        ...state,\n        selectedPieceCoordinate: null,\n        availableTurnRoutes: defaultAvailableTurnCells,\n      };\n    }\n\n    case RISE_PIECE: {\n      const availableTurnRoutes = getAvailableRoutes(state.cells, action.payload);\n      return {\n        ...state,\n        selectedPieceCoordinate: action.payload,\n        availableTurnRoutes,\n      };\n    }\n\n    case HOVER_CELL: {\n      const availableTurnRoutes = action.payload\n        ? getAvailableRoutes(state.cells, action.payload)\n        : defaultAvailableTurnCells;\n      return {\n        ...state,\n        hoveredCellCoordinate: action.payload,\n        availableTurnRoutes,\n      };\n    }\n\n    case MOVE_PIECE: {\n      const { fromCoordinate, toCoordinate } = action.payload;\n      const nextPlayer = getNextPlayer(state.currentPlayer, false);\n      const updatedCellsState = getStateWithMovedPiece(state.cells, fromCoordinate, toCoordinate);\n      const availableTurnPieces = getAvailableTurnPieces(updatedCellsState, nextPlayer);\n\n      return {\n        ...state,\n        cells: updatedCellsState,\n        selectedPieceCoordinate: null,\n        mandatoryTurnPiece: null,\n        history: [getHistoryEntry(state), ...state.history],\n        availableTurnRoutes: defaultAvailableTurnCells,\n        availableTurnPieces,\n        currentPlayer: nextPlayer,\n      };\n    }\n\n    case HIT_PIECE: {\n      const { fromCoordinate, hitCoordinate, toCoordinate } = action.payload;\n      const stateAfterHit = getStateWithHitPiece(\n        state.cells,\n        fromCoordinate,\n        hitCoordinate,\n        toCoordinate,\n      );\n      const mandatoryTurnPiece = getMandatoryTurnPieceAfterHitCoordinate(\n        stateAfterHit,\n        toCoordinate,\n      );\n      const nextPlayer = getNextPlayer(state.currentPlayer, mandatoryTurnPiece !== null);\n      const updatedState = getStateWithHitPiece(\n        state.cells,\n        fromCoordinate,\n        hitCoordinate,\n        toCoordinate,\n      );\n      const availableTurnPieces = mandatoryTurnPiece !== null\n        ? [mandatoryTurnPiece]\n        : getAvailableTurnPieces(updatedState, nextPlayer);\n\n      return {\n        ...state,\n        cells: updatedState,\n        selectedPieceCoordinate: null,\n        mandatoryTurnPiece,\n        availableTurnPieces,\n        history: [getHistoryEntry(state), ...state.history],\n        availableTurnRoutes: defaultAvailableTurnCells,\n        currentPlayer: nextPlayer,\n      };\n    }\n\n    case UNDO: {\n      const lastState = state.history[0];\n\n      return {\n        ...state,\n        ...lastState,\n        history: state.history.slice(1),\n      };\n    }\n\n    case NEW_GAME: {\n      return {\n        ...defaultGameState,\n        mode: action.payload,\n      };\n    }\n\n    case SET_STATE: {\n      return action.payload;\n    }\n\n    default:\n      return state;\n  }\n};\n","import { GameState } from './store/game/reducer';\n\nconst LOCAL_STORAGE_KEY = 'checkers-game';\n\nexport function saveGameToLocalStorage(game: GameState): void {\n  window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(game));\n}\n\nexport function clearGameFromLocalStorage(): void {\n  window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n}\n\nexport function readGameFromLocalStorage(): GameState | null {\n  const savedGame = localStorage.getItem(LOCAL_STORAGE_KEY);\n\n  return savedGame && JSON.parse(savedGame);\n}\n","import { RootState } from '../index';\nimport {\n  Coordinate, Piece, Route, PlayerType, GameMode,\n} from '../../types';\nimport { areCoordinatesEqual, getCellIndex } from '../../utils/common';\n\nexport const selectGameState = (state: RootState) => state.game;\n\nexport const selectCells = (state: RootState) => state.game.cells;\n\nexport const getSelectPieceState = (\n  coordinate: Coordinate,\n) => (state: RootState): Piece | null => {\n  const cell = state.game.cells[getCellIndex(coordinate)];\n\n  return cell ? cell.piece : null;\n};\n\nexport const selectSelectedPieceCoordinate = (\n  state: RootState,\n): Coordinate | null => state.game.selectedPieceCoordinate;\n\nexport const getSelectIsPieceRisen = (\n  coordinate: Coordinate,\n) => (state: RootState): boolean => {\n  const piece = getSelectPieceState(coordinate)(state);\n  const selectedPieceCoordinate = selectSelectedPieceCoordinate(state);\n\n  if (\n    piece === null\n    || selectedPieceCoordinate === null\n  ) {\n    return false;\n  }\n\n  return areCoordinatesEqual(\n    coordinate,\n    selectedPieceCoordinate,\n  );\n};\n\nexport const selectAvailableTurnCells = (\n  state: RootState,\n): Route[] => state.game.availableTurnRoutes;\n\nexport const selectCurrentPlayer = (\n  state: RootState,\n): PlayerType => state.game.currentPlayer;\n\nexport const selectGameMode = (\n  state: RootState,\n): GameMode => state.game.mode;\n\nexport const selectMandatoryTurnPiece = (\n  state: RootState,\n): Coordinate | null => state.game.mandatoryTurnPiece;\n\nexport const getSelectIsPieceAvailableForTurn = (coordinate: Coordinate) => (\n  state: RootState,\n): boolean => state.game.availableTurnPieces\n  .some((availablePieceCoordinate) => areCoordinatesEqual(coordinate, availablePieceCoordinate));\n","import {\n  AnyAction, Dispatch, MiddlewareAPI,\n} from 'redux';\nimport {\n  GameAction, HIT_PIECE, MOVE_PIECE, UNDO,\n} from './game/actions';\nimport { saveGameToLocalStorage } from '../LocalStorageHandler';\nimport { selectGameState } from './game/selectors';\nimport { RootState } from './index';\n\nconst localStorageMiddleware = (\n  { getState }: MiddlewareAPI<Dispatch, RootState>,\n) => (next: Dispatch<AnyAction>) => (action: GameAction): AnyAction => {\n  // Do something in here, when each action is dispatched\n  const nextAction = next(action);\n  const state = getState();\n\n  if ([\n    MOVE_PIECE,\n    HIT_PIECE,\n    UNDO,\n  ].includes(action.type)) {\n    saveGameToLocalStorage(selectGameState(state));\n  }\n\n  return nextAction;\n};\n\nexport default localStorageMiddleware;\n","import {\n  createStore, combineReducers, applyMiddleware,\n} from 'redux';\n\nimport { GameState, reducer } from './game/reducer';\nimport localStorageMiddleware from './localStorageMiddleware';\n\nexport interface RootState {\n  game: GameState,\n}\n\nconst store = createStore(combineReducers<RootState>({\n  game: reducer,\n}), applyMiddleware(localStorageMiddleware));\n\nexport default store;\n","import React from 'react';\n\nconst usePrevious = <ValueType>(value: ValueType): ValueType | undefined => {\n  const ref = React.useRef<ValueType>();\n\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n};\n\nexport default usePrevious;\n","import React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { selectCells, selectCurrentPlayer, selectMandatoryTurnPiece } from '../../store/game/selectors';\nimport { getAvailableRoutes, getAvailableTurnPieces, isRouteWithHitPiece } from '../../utils/game';\nimport { getRandomInt } from '../../utils/common';\nimport { hitPiece, movePiece } from '../../store/game/actions';\nimport { Coordinate, Route } from '../../types';\nimport usePrevious from '../../hooks/usePrevious';\n\nexport const AI_PLAYER = 'black';\n\nconst AI_MOVE_DELAY_MS = 500;\n\nconst DummyAI: React.FC = () => {\n  const dispatch = useDispatch();\n\n  const cells = useSelector(selectCells);\n  const currentPlayer = useSelector(selectCurrentPlayer);\n  const mandatoryTurnPiece = useSelector(selectMandatoryTurnPiece);\n  const previousPlayer = usePrevious(currentPlayer);\n  const previousMandatoryTurnPiece = usePrevious(mandatoryTurnPiece);\n\n  React.useEffect(() => {\n    console.log('IM ALIVE');\n\n    return () => {\n      console.log('I`LL BE BACK');\n    };\n  }, []);\n\n  const hitPieceAction = React.useCallback((pieceCoordinate: Coordinate, hitRoute: Route) => {\n    const hitPieceCoordinate = hitRoute[hitRoute.length - 2].coordinate;\n    const cellAfterHitCoordinate = hitRoute[hitRoute.length - 1].coordinate;\n\n    console.log('HEHE! I WILL HIT: ', hitPieceCoordinate);\n\n    window.setTimeout(() => {\n      dispatch(hitPiece(pieceCoordinate, hitPieceCoordinate, cellAfterHitCoordinate));\n    }, AI_MOVE_DELAY_MS);\n  }, [dispatch]);\n\n  const movePieceAction = React.useCallback((pieceCoordinate: Coordinate, moveRoute: Route) => {\n    const moveCoordinate = moveRoute[getRandomInt(0, moveRoute.length)].coordinate;\n\n    console.log('MOVING TO: ', moveCoordinate);\n\n    window.setTimeout(() => {\n      dispatch(movePiece(pieceCoordinate, moveCoordinate));\n    }, AI_MOVE_DELAY_MS);\n  }, [dispatch]);\n\n  React.useEffect(() => {\n    if (currentPlayer !== previousPlayer && currentPlayer === AI_PLAYER) {\n      console.log('MY TURN!');\n\n      const availableTurnPieces = getAvailableTurnPieces(cells, AI_PLAYER);\n\n      if (!availableTurnPieces.length) {\n        console.log('OOOPS, I GIVE UP');\n\n        return;\n      }\n\n      console.log('I CAN MOVE: ', availableTurnPieces);\n      const chosenPiece = availableTurnPieces[getRandomInt(0, availableTurnPieces.length)];\n\n      console.log('I HAVE DECIDED TO MOVE: ', chosenPiece);\n\n      const availableRoutes = getAvailableRoutes(cells, chosenPiece);\n\n      console.log('I CAN MOVE IT TO: ', availableRoutes);\n\n      const chosenRoute = availableRoutes[getRandomInt(0, availableRoutes.length)];\n\n      console.log('I CHOOSE TO GO THIS WAY: ', chosenRoute);\n\n      if (chosenRoute.length > 1) {\n        hitPieceAction(chosenPiece, chosenRoute);\n      } else {\n        movePieceAction(chosenPiece, chosenRoute);\n      }\n    }\n\n    if (\n      previousMandatoryTurnPiece !== mandatoryTurnPiece\n      && mandatoryTurnPiece !== null\n      && currentPlayer === AI_PLAYER\n    ) {\n      console.log('I`M MACHINEEE! I HIT AGAIN: ', mandatoryTurnPiece);\n\n      const availableRoutes = getAvailableRoutes(cells, mandatoryTurnPiece);\n      const chosenRoute = availableRoutes[getRandomInt(0, availableRoutes.length)];\n\n      console.log('I CHOOSE TO GO AND HIT THIS WAY: ', chosenRoute);\n\n      if (isRouteWithHitPiece(chosenRoute)) {\n        hitPieceAction(mandatoryTurnPiece, chosenRoute);\n      } else {\n        console.log('OOOPS! SOMETHING WENT WRONG');\n      }\n    }\n  }, [\n    dispatch,\n    cells,\n    currentPlayer,\n    previousPlayer,\n    previousMandatoryTurnPiece,\n    mandatoryTurnPiece,\n    hitPieceAction,\n    movePieceAction,\n  ]);\n\n  return null;\n};\n\nexport default DummyAI;\n","import { useSelector } from 'react-redux';\nimport { Coordinate } from '../types';\nimport { selectAvailableTurnCells } from '../store/game/selectors';\nimport { getRouteWithCell } from '../utils/game';\n\nconst useIsCellUnderHit = (coordinate: Coordinate): boolean => {\n  const availableTurnCells = useSelector(selectAvailableTurnCells);\n  const availableRoute = getRouteWithCell(availableTurnCells, coordinate);\n\n  if (!availableRoute) {\n    return false;\n  }\n\n  return availableRoute.some((routeItem) => routeItem.cell.piece);\n};\n\nexport default useIsCellUnderHit;\n","import { useSelector } from 'react-redux';\n\nimport { Coordinate } from '../../types';\nimport { getSelectIsPieceAvailableForTurn, selectCurrentPlayer, selectGameMode } from '../../store/game/selectors';\nimport { AI_PLAYER } from '../ai/DummyAI';\n\nconst useIsPieceInteractive = (coordinate: Coordinate): boolean => {\n  const isAvailable = useSelector(getSelectIsPieceAvailableForTurn(coordinate));\n  const gameMode = useSelector(selectGameMode);\n  const currentPlayer = useSelector(selectCurrentPlayer);\n\n  return gameMode === 'AI'\n    ? currentPlayer !== AI_PLAYER && isAvailable\n    : isAvailable;\n};\n\nexport default useIsPieceInteractive;\n","import { useSelector } from 'react-redux';\n\nimport { Coordinate } from '../../types';\nimport {\n  selectMandatoryTurnPiece,\n} from '../../store/game/selectors';\nimport { areCoordinatesEqual } from '../../utils/common';\n\nconst useIsPieceMandatoryToMakeTurn = (coordinate: Coordinate): boolean => {\n  const mandatoryTurnPiece = useSelector(selectMandatoryTurnPiece);\n  return mandatoryTurnPiece !== null\n    && areCoordinatesEqual(mandatoryTurnPiece, coordinate);\n};\n\nexport default useIsPieceMandatoryToMakeTurn;\n","import { createGlobalStyle, css } from 'styled-components';\n\nexport const BOARD_SIZE_PX = 440;\n\nexport const CELL_SIZE = BOARD_SIZE_PX / 8;\n\nexport const COLOR_BLACK = '#222';\nexport const COLOR_WHITE = '#ffece4';\n\nexport const COLOR_MAIN = '#ff804d';\nexport const COLOR_ACCENT = '#fb5';\n\nexport const getDottedPattern = (sizePx = 2, color = COLOR_BLACK) => css`\n  background-image:\n    linear-gradient(45deg, ${color} 25%, transparent 25%),\n    linear-gradient(-45deg, ${color} 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, ${color} 75%),\n    linear-gradient(-45deg, transparent 75%, ${color} 75%);\n  background-size: ${sizePx}px ${sizePx}px;\n  background-position: 0 0, 0 ${sizePx / 2}px, ${sizePx / 2}px -${sizePx / 2}px, -${sizePx / 2}px 0px;\n`;\n\nexport const getStripedPattern = (sizePx = 2, color = COLOR_BLACK) => css`\n  background-image: linear-gradient(45deg, ${color} 25%, transparent 25%, transparent 50%, ${color} 50%, ${color} 75%, transparent 75%, transparent 100%);\n  background-size: ${sizePx * 2}px ${sizePx * 2}px;\n`;\n\nexport const GlobalStyle = createGlobalStyle`\n  html, body, #root {\n    width: 100%;\n    height: 100%;\n    font-family: 'Courier New', monospace;\n    background: #ff804d;\n    user-select: none;\n  }\n`;\n","import styled, { css } from 'styled-components';\n\nimport {\n  CELL_SIZE, COLOR_ACCENT, COLOR_BLACK, COLOR_WHITE, getDottedPattern,\n} from '../../common.styled';\nimport { Color } from '../../types';\n\ninterface PieceContainerProps {\n  isRisen: boolean;\n  isVisible: boolean;\n  isPieceHit: boolean;\n  pieceColor: Color;\n  isInteractive?: boolean\n}\n\nexport const $PieceContainer = styled.div<PieceContainerProps>`\n  position: ${({ isRisen }) => (isRisen ? 'fixed' : 'relative')};\n  width: ${CELL_SIZE}px;\n  height: ${CELL_SIZE}px;\n  z-index: ${({ isRisen }) => (isRisen ? 10 : 1)};\n  visibility: ${({ isVisible }) => (isVisible ? 'visible' : 'hidden')};\n  \n  cursor: ${({ isRisen }) => (isRisen ? 'grabbing' : 'grab')};\n  pointer-events: ${({ isInteractive }) => (isInteractive ? 'all' : 'none')};\n  \n  ${(props) => props.isPieceHit && css`\n    &:after,\n    &:before {\n      position: absolute;\n      display: block;\n      width: 2px;\n      height: ${CELL_SIZE}px;\n      left: 0;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      margin: auto;\n      background-color: ${props.pieceColor === 'white' ? COLOR_BLACK : COLOR_WHITE};\n      transform-origin: 50% 50%;\n      content: '';\n      z-index: 1;\n    }\n    \n    &:before {\n      transform: rotate(45deg);\n    }\n    \n    &:after {\n      transform: rotate(-45deg);\n    }\n  `}\n`;\n\nexport const $Piece = styled.div<{\n  pieceColor: Color;\n  isRisen: boolean;\n  isMandatory?: boolean;\n  isQueen?: boolean;\n}>`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  background-color: ${(props) => (props.pieceColor === 'white' ? COLOR_WHITE : COLOR_BLACK)};\n  box-sizing: border-box;\n  border: 4px solid ${(props) => (props.isMandatory ? COLOR_ACCENT : COLOR_BLACK)};\n  \n  &:before,\n  &:after {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n    display: block;\n    border-radius: 50%;\n    border: 2px solid ${(props) => (props.pieceColor === 'white' ? COLOR_BLACK : COLOR_WHITE)};\n    content: '';\n  }\n  \n  &:before {\n    width: 70%;\n    height: 70%;\n    ${(props) => props.isQueen && css`\n      border: 2px solid ${COLOR_ACCENT};\n    `}\n  }\n  \n  &:after {\n    width: 40%;\n    height: 40%;\n    ${(props) => props.isQueen && css`\n      font-weight: bold;\n      border: 2px solid ${COLOR_ACCENT};\n      color: ${COLOR_ACCENT};\n      content: 'Q';\n    `}\n  }\n`;\n\nexport const $Shadow = styled.div<{ isVisible: boolean }>`\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  visibility: ${(props) => (props.isVisible ? 'visible' : 'hidden')};\n  top: 2px;\n  left: 2px;\n  \n  ${getDottedPattern()};\n`;\n","import React, { MouseEventHandler } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport {\n  getSelectIsPieceRisen,\n  getSelectPieceState,\n  selectCurrentPlayer,\n  selectSelectedPieceCoordinate,\n} from '../../store/game/selectors';\nimport { hoverPiece, risePiece } from '../../store/game/actions';\nimport { Coordinate } from '../../types';\nimport useIsCellUnderHit from '../../hooks/useIsCellUnderHit';\n\nimport useIsPieceInteractive from './useIsPieceInteractive';\nimport useIsPieceMandatoryToMakeTurn from './useIsPieceMandatoryToMakeTurn';\n\nimport { $Piece, $PieceContainer } from './Piece.styled';\n\ninterface CellProps {\n  coordinate: Coordinate;\n}\n\nconst Piece: React.FC<CellProps> = ({ coordinate }) => {\n  const dispatch = useDispatch();\n  const pieceElementRef = React.createRef<HTMLDivElement>();\n\n  const piece = useSelector(getSelectPieceState(coordinate));\n  const isRisen = useSelector(getSelectIsPieceRisen(coordinate));\n  const selectedPieceCoordinates = useSelector(selectSelectedPieceCoordinate);\n  const currentPlayer = useSelector(selectCurrentPlayer);\n\n  const isPieceHit = useIsCellUnderHit(coordinate);\n  const isMandatory = useIsPieceMandatoryToMakeTurn(coordinate);\n  const isPieceInteractive = useIsPieceInteractive(coordinate);\n\n  const onKeyDown = React.useCallback(() => {\n    if (!piece || currentPlayer !== piece.color) {\n      return;\n    }\n\n    dispatch(risePiece(coordinate));\n  }, [dispatch, piece, currentPlayer, coordinate]);\n\n  const onMouseEnter: MouseEventHandler<HTMLDivElement> = React.useCallback(() => {\n    if (currentPlayer !== piece?.color || selectedPieceCoordinates) {\n      return;\n    }\n\n    dispatch(hoverPiece(coordinate));\n  }, [dispatch, coordinate, currentPlayer, piece, selectedPieceCoordinates]);\n\n  const onMouseLeave: MouseEventHandler<HTMLDivElement> = React.useCallback(() => {\n    if (currentPlayer !== piece?.color || selectedPieceCoordinates) {\n      return;\n    }\n\n    dispatch(hoverPiece(null));\n  }, [dispatch, currentPlayer, piece, selectedPieceCoordinates]);\n\n  return piece\n    ? (\n      <$PieceContainer\n        ref={pieceElementRef}\n        isRisen={isRisen}\n        isVisible={!isRisen}\n        isPieceHit={isPieceHit}\n        pieceColor={piece.color}\n        isInteractive={isPieceInteractive}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n      >\n        <$Piece\n          onMouseDown={onKeyDown}\n          pieceColor={piece.color}\n          isMandatory={isMandatory}\n          isQueen={piece.isQueen}\n          isRisen={false}\n        />\n      </$PieceContainer>\n    )\n    : null;\n};\n\nexport default Piece;\n","import { useSelector } from 'react-redux';\n\nimport { Coordinate } from '../../types';\nimport { getSelectPieceState, selectAvailableTurnCells } from '../../store/game/selectors';\nimport { getRouteWithCell } from '../../utils/game';\nimport useIsCellUnderHit from '../../hooks/useIsCellUnderHit';\n\nimport { CellHighLight } from './Cell.styled';\n\nconst useGetCellHighlight = (coordinate: Coordinate): CellHighLight => {\n  const currentCellPiece = useSelector(getSelectPieceState(coordinate));\n  const availableTurnCells = useSelector(selectAvailableTurnCells);\n  const availableRoute = getRouteWithCell(availableTurnCells, coordinate);\n\n  const isHitRoute = useIsCellUnderHit(coordinate);\n\n  if (!availableRoute) {\n    return 'none';\n  }\n\n  if (isHitRoute) {\n    return currentCellPiece ? 'hit' : 'available';\n  }\n\n  return 'available';\n};\n\nexport default useGetCellHighlight;\n","import { useDispatch, useSelector } from 'react-redux';\nimport React from 'react';\n\nimport { Coordinate } from '../../types';\nimport { selectAvailableTurnCells, selectSelectedPieceCoordinate } from '../../store/game/selectors';\nimport { getRouteWithCell } from '../../utils/game';\nimport { hitPiece, movePiece } from '../../store/game/actions';\n\nconst useGetCellAction = (coordinate: Coordinate): () => void => {\n  const dispatch = useDispatch();\n  const availableTurnCells = useSelector(selectAvailableTurnCells);\n  const selectedPieceCoordinates = useSelector(selectSelectedPieceCoordinate);\n\n  const availableRoute = getRouteWithCell(availableTurnCells, coordinate);\n\n  return React.useCallback(() => {\n    if (!availableRoute || !selectedPieceCoordinates) {\n      // no available turns to this cell\n      return;\n    }\n\n    const hitPieceRouteItem = availableRoute.find((routeItem) => routeItem.cell.piece);\n\n    if (hitPieceRouteItem) {\n      dispatch(hitPiece(\n        selectedPieceCoordinates,\n        hitPieceRouteItem.coordinate,\n        coordinate,\n      ));\n    } else {\n      dispatch(movePiece(\n        selectedPieceCoordinates,\n        coordinate,\n      ));\n    }\n  }, [dispatch, selectedPieceCoordinates, coordinate, availableRoute]);\n};\n\nexport default useGetCellAction;\n","import styled, { css } from 'styled-components';\n\nimport { CELL_SIZE, COLOR_MAIN, getStripedPattern } from '../../common.styled';\n\nexport type CellHighLight = 'none' | 'hit' | 'available';\n\nconst getBackgroundColor = (highlight: CellHighLight) => {\n  switch (highlight) {\n    case 'available': {\n      return getStripedPattern(2, 'rgba(255, 255, 255, 0.5)');\n    }\n    case 'hit': {\n      return getStripedPattern(2, 'rgba(255, 0, 0, 0.5)');\n    }\n    case 'none':\n    default: {\n      return css`\n        background: ${COLOR_MAIN};\n      `;\n    }\n  }\n};\n\nexport const $Cell = styled.div<{highlight: CellHighLight; hasOffset?: boolean}>`\n  position: relative;\n  width: ${CELL_SIZE}px;\n  height: ${CELL_SIZE}px;\n  background-color: ${COLOR_MAIN};\n  \n  ${(props) => props.hasOffset && css`\n    margin-left: ${CELL_SIZE}px;\n  `}\n  \n  ${(props) => getBackgroundColor(props.highlight)};\n`;\n","import React from 'react';\n\nimport Piece from '../piece/Piece';\nimport { Coordinate } from '../../types';\n\nimport useGetCellHighlight from './useGetCellHighlight';\nimport useGetCellAction from './useGetCellAction';\n\nimport { $Cell } from './Cell.styled';\n\ninterface CellProps {\n  coordinate: Coordinate,\n  hasOffset: boolean;\n}\n\nconst Cell: React.FC<CellProps> = ({ coordinate, hasOffset }) => {\n  const highlight = useGetCellHighlight(coordinate);\n  const onMouseUp = useGetCellAction(coordinate);\n\n  return (\n    <$Cell\n      onMouseUp={onMouseUp}\n      hasOffset={hasOffset}\n      highlight={highlight}\n    >\n      <Piece coordinate={coordinate} />\n    </$Cell>\n  );\n};\n\nexport default Cell;\n","import * as React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { putPiece } from '../../store/game/actions';\nimport { selectCurrentPlayer, selectSelectedPieceCoordinate } from '../../store/game/selectors';\n\nimport { $Piece, $PieceContainer, $Shadow } from '../piece/Piece.styled';\nimport { CELL_SIZE } from '../../common.styled';\n\nconst DragNDropLayer: React.FC = () => {\n  const dispatch = useDispatch();\n\n  const pieceElementRef = React.useRef<HTMLDivElement>(null);\n\n  const selectedPieceCoordinates = useSelector(selectSelectedPieceCoordinate);\n  const player = useSelector(selectCurrentPlayer);\n\n  const onMouseDown = React.useCallback((event: MouseEvent) => {\n    if (selectedPieceCoordinates || !pieceElementRef.current) {\n      return;\n    }\n    pieceElementRef.current.style.top = `${event.clientY - (CELL_SIZE / 2)}px`;\n    pieceElementRef.current.style.left = `${event.clientX - (CELL_SIZE / 2)}px`;\n  }, [pieceElementRef, selectedPieceCoordinates]);\n\n  const onMouseUp = React.useCallback(() => {\n    if (!selectedPieceCoordinates) {\n      return;\n    }\n    dispatch(putPiece(selectedPieceCoordinates));\n  }, [dispatch, selectedPieceCoordinates]);\n\n  const onMouseMove = React.useCallback((event: MouseEvent) => {\n    if (!selectedPieceCoordinates || !pieceElementRef.current) {\n      return;\n    }\n\n    pieceElementRef.current.style.top = `${event.clientY - (CELL_SIZE / 2)}px`;\n    pieceElementRef.current.style.left = `${event.clientX - (CELL_SIZE / 2)}px`;\n  }, [selectedPieceCoordinates, pieceElementRef]);\n\n  React.useEffect(() => {\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    document.addEventListener('mousemove', onMouseMove);\n\n    return () => {\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  });\n\n  return (\n    <$PieceContainer\n      isRisen\n      ref={pieceElementRef}\n      isVisible={!!selectedPieceCoordinates}\n      isInteractive={false}\n      isPieceHit={false}\n      pieceColor={player}\n    >\n      <$Shadow isVisible={!!selectedPieceCoordinates} />\n      <$Piece\n        pieceColor={player}\n        isRisen\n      />\n    </$PieceContainer>\n  );\n};\n\nexport default DragNDropLayer;\n","import styled, { css } from 'styled-components';\n\nimport {\n  BOARD_SIZE_PX, COLOR_ACCENT, COLOR_BLACK, COLOR_MAIN, COLOR_WHITE,\n} from '../../common.styled';\n\nexport const $Board = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  width: ${BOARD_SIZE_PX}px;\n  height: ${BOARD_SIZE_PX}px;\n  border: 6px solid ${COLOR_ACCENT};\n  border-radius: 10px;\n  background: #ffece4;\n  box-shadow: 10px 10px ${COLOR_BLACK};\n  overflow: hidden;\n`;\n\nexport const $PlayerName = styled.div<{ isActive: boolean; position: 'top' | 'bottom' }>`\n  display: flex;\n  flex-wrap: wrap;\n  \n  background: ${(props) => (props.isActive ? COLOR_WHITE : COLOR_MAIN)};\n  border: 6px solid ${COLOR_ACCENT};\n  border-radius: ${(props) => (\n    props.position === 'top' ? '10px 10px 0 0 ' : '0 0 10px 10px'\n  )};\n  box-shadow: 10px 10px ${COLOR_BLACK};\n      padding: 10px 50px;\n    letter-spacing: 4px;\n    font-weight: bold;\n  \n  ${(props) => (props.position === 'top'\n    ? css`border-bottom: none;` : css`border-top: none;`)};\n`;\n","import React from 'react';\nimport { useSelector } from 'react-redux';\nimport Cell from '../cell/Cell';\nimport { createBoardSchema, getCellIndex } from '../../utils/common';\nimport { selectCurrentPlayer, selectGameMode } from '../../store/game/selectors';\n\nimport DragNDropLayer from './DragNDropLayer';\n\nimport { $Board, $PlayerName } from './BoardLayout.styled';\n\nconst defaultSchema = createBoardSchema();\n\nconst BoardLayout: React.FC = () => {\n  const activePlayer = useSelector(selectCurrentPlayer);\n  const gameMode = useSelector(selectGameMode);\n\n  return (\n    <>\n      <DragNDropLayer />\n      <$PlayerName\n        position=\"top\"\n        isActive={activePlayer === 'black'}\n      >\n        {gameMode === 'AI' ? 'Dummy AI' : 'Player 2'}\n      </$PlayerName>\n      <$Board>\n        {defaultSchema\n          .map((row, rowIndex) => row\n            .map((cell, colIndex) => {\n              const prevCell = row[colIndex - 1];\n              const coordinates = {\n                colIndex,\n                rowIndex,\n              };\n              return (\n                cell\n                  ? (\n                    <Cell\n                    // eslint-disable-next-line react/no-array-index-key\n                      key={getCellIndex({ rowIndex, colIndex })}\n                      coordinate={coordinates}\n                      hasOffset={prevCell !== undefined && !prevCell}\n                    />\n                  )\n                  : null\n              );\n            }))}\n      </$Board>\n      <$PlayerName\n        position=\"bottom\"\n        isActive={activePlayer === 'white'}\n      >\n        Player 1\n      </$PlayerName>\n    </>\n  );\n};\n\nexport default BoardLayout;\n","import styled from 'styled-components';\n\nimport { COLOR_BLACK, COLOR_WHITE } from '../../common.styled';\n\nconst ACTION_OFFSET_PX = 2;\nconst SHADOW_SIZE_PX = 4;\n\nconst $Button = styled.button`\n    box-sizing: border-box;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    margin: 22px;\n    padding: 10px 22px;\n    border: 2px solid ${COLOR_BLACK};\n    border-radius: 6px;\n    background: ${COLOR_WHITE};\n    box-shadow: ${SHADOW_SIZE_PX}px ${SHADOW_SIZE_PX}px ${COLOR_BLACK};\n    font-weight: bold;\n    font-size: 16px;\n    text-transform: uppercase;\n    outline: none;\n    cursor: pointer;\n    white-space: nowrap;\n    \n    &:hover {\n      transform: translate(-${ACTION_OFFSET_PX}px, -${ACTION_OFFSET_PX}px);\n      box-shadow: ${SHADOW_SIZE_PX + ACTION_OFFSET_PX}px ${SHADOW_SIZE_PX + ACTION_OFFSET_PX}px black;\n    }\n    \n    &:active {\n      transform: translate(${ACTION_OFFSET_PX}px, ${ACTION_OFFSET_PX}px);\n      box-shadow: 0 0 black;\n    }\n`;\n\nexport default $Button;\n","import React from 'react';\n\nimport $Button from './MenuButton.styled';\n\ninterface MenuButtonProps {\n  label: string;\n  onClick: () => void;\n}\n\nconst MenuButton: React.FC<MenuButtonProps> = ({ label, onClick }) => (\n  <$Button type=\"button\" onClick={onClick}>{label}</$Button>\n);\n\nexport default MenuButton;\n","import styled from 'styled-components';\n\nexport const $StartGameContainer = styled.div`\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n`;\n\nexport const $Title = styled.h2`\n  text-transform: uppercase;\n`;\n","import React from 'react';\n\nimport MenuButton from '../menu-button/MenuButton';\nimport { GameMode } from '../../types';\n\nimport { $Title, $StartGameContainer } from './StartGame.styled';\n\ninterface StartGameProps {\n  onModeSelect: (mode: GameMode) => void;\n}\n\nconst StartGame: React.FC<StartGameProps> = ({ onModeSelect }) => {\n  const onPvPChosen = () => onModeSelect('PvP');\n  const onAIChosen = () => onModeSelect('AI');\n\n  return (\n    <$StartGameContainer>\n      <$Title>New game</$Title>\n      <MenuButton label=\"Player vs Player\" onClick={onPvPChosen} />\n      <MenuButton label=\"Player vs 'AI'\" onClick={onAIChosen} />\n    </$StartGameContainer>\n  );\n};\n\nexport default StartGame;\n","import styled from 'styled-components';\n\nconst $Container = styled.div`\n    box-sizing: border-box;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nexport default $Container;\n","import React from 'react';\n\nimport MenuButton from '../menu-button/MenuButton';\n\nimport $Container from './BoardMenu.styled';\n\ninterface MenuButtonProps {\n  onUndo: () => void;\n  onStartNewGame: () => void;\n}\n\nconst BoardMenu: React.FC<MenuButtonProps> = ({ onUndo, onStartNewGame }) => (\n  <$Container>\n    <MenuButton label=\"Undo\" onClick={onUndo} />\n    <MenuButton label=\"New game\" onClick={onStartNewGame} />\n  </$Container>\n);\n\nexport default BoardMenu;\n","import styled from 'styled-components';\n\nexport const $WinnerContainer = styled.div`\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n`;\n\nexport const $Title = styled.h2`\n  text-transform: uppercase;\n  font-size: 60px;\n`;\n","import React from 'react';\n\nimport MenuButton from '../menu-button/MenuButton';\nimport { PlayerType } from '../../types';\n\nimport { $WinnerContainer, $Title } from './Winner.styled';\n\ninterface MenuButtonProps {\n  winner: PlayerType | null;\n  onStartNewGame: () => void;\n}\n\nconst Winner: React.FC<MenuButtonProps> = ({ winner, onStartNewGame }) => (\n  winner\n    ? (\n      <$WinnerContainer>\n        <$Title>\n          {`${winner} player wins!`}\n        </$Title>\n        <MenuButton label=\"New game\" onClick={onStartNewGame} />\n      </$WinnerContainer>\n    )\n    : null\n);\n\nexport default Winner;\n","import React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport BoardLayout from '../board/BoardLayout';\nimport StartGame from '../start-game/StartGame';\nimport { GameMode, PlayerType } from '../../types';\nimport { clearGameFromLocalStorage, readGameFromLocalStorage } from '../../LocalStorageHandler';\nimport { setGameState, startGame, undo } from '../../store/game/actions';\nimport BoardMenu from '../board-menu/BoardMenu';\nimport { selectCells } from '../../store/game/selectors';\nimport { getWinner } from '../../utils/game';\nimport Winner from '../winner/Winner';\n\ntype Screen = 'start' | 'main' | 'winner';\n\nconst MainContainerContent: React.FC = () => {\n  const dispatch = useDispatch();\n\n  const [screen, setScreen] = React.useState<Screen>('start');\n  const [winner, setWinner] = React.useState<PlayerType | null>(null);\n\n  const cells = useSelector(selectCells);\n\n  // track winner\n  React.useEffect(() => {\n    const currentWinner = getWinner(cells);\n\n    if (currentWinner !== null) {\n      setWinner(currentWinner);\n      setScreen('winner');\n    }\n  }, [cells]);\n\n  // load game from local storage on mount\n  React.useEffect(() => {\n    const savedState = readGameFromLocalStorage();\n\n    if (savedState !== null) {\n      dispatch(setGameState(savedState));\n      setScreen('main');\n    } else {\n      setScreen('start');\n    }\n  }, [dispatch]);\n\n  const openStartScreen = React.useCallback(() => {\n    clearGameFromLocalStorage();\n    setScreen('start');\n  }, []);\n\n  const onStartGame = React.useCallback((gameMode: GameMode) => {\n    dispatch(startGame(gameMode));\n    clearGameFromLocalStorage();\n    setScreen('main');\n  }, [dispatch]);\n\n  const onUndo = () => {\n    dispatch(undo());\n  };\n\n  switch (screen) {\n    case 'main':\n      return (\n        <>\n          <BoardLayout />\n          <BoardMenu onUndo={onUndo} onStartNewGame={openStartScreen} />\n        </>\n      );\n    case 'winner':\n      return (\n        <Winner winner={winner} onStartNewGame={openStartScreen} />\n      );\n    case 'start':\n    default:\n      return (\n        <StartGame onModeSelect={onStartGame} />\n      );\n  }\n};\n\nexport default MainContainerContent;\n","import styled from 'styled-components';\n\nimport { BOARD_SIZE_PX, COLOR_BLACK, COLOR_WHITE } from '../../common.styled';\n\nexport const $MainContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  margin: auto;\n  width: ${BOARD_SIZE_PX}px;\n  text-align: center;\n`;\n\nexport const $MainHeader = styled.h1`\n  margin: 10px;\n  padding: 20px 28px;\n  font-size: 48px;\n  color: ${COLOR_BLACK};\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  text-shadow: 2px 2px 0 ${COLOR_WHITE};\n`;\n","import React from 'react';\nimport { useSelector } from 'react-redux';\n\nimport { selectGameMode } from '../../store/game/selectors';\nimport DummyAI from '../ai/DummyAI';\n\nimport MainContainerContent from './MainContainerContent';\n\nimport { $MainContainer, $MainHeader } from './MainContainer.styled';\n\nconst MainContainer: React.FC = () => {\n  const currentGameMode = useSelector(selectGameMode);\n\n  return (\n    <$MainContainer>\n      <$MainHeader>\n        CHECKERS\n      </$MainHeader>\n      <MainContainerContent />\n      {currentGameMode === 'AI' && <DummyAI />}\n    </$MainContainer>\n  );\n};\n\nexport default MainContainer;\n","import React from 'react';\nimport { Provider } from 'react-redux';\n\nimport 'normalize.css';\n\nimport store from './store';\nimport MainContainer from './components/main-container/MainContainer';\nimport { GlobalStyle } from './common.styled';\n\nconst App: React.FC = () => (\n  <>\n    <GlobalStyle />\n    <Provider store={store}>\n      <MainContainer />\n    </Provider>\n  </>\n);\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}